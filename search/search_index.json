{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>This package is aimed to be a modern, efficient and compliant CANopen stack written entirely in go. It features both slave &amp; master control and supports dynamic OD creation directly via EDS file.</p> <p>This project has been inspired by two other existing projects:</p> <ul> <li>CANopenNode a C implementation slave side.</li> <li>canopen a python implementation mostly for master control.</li> </ul> <p>This project implements both slave &amp; master side using an efficient API. Currently the following is implemented :</p> Service name Implemented SDO server yes SDO client yes NMT master yes NMT slave yes HB producer yes HB consumer yes TPDO yes RPDO yes EMERGENCY  producer yes EMERGENCY  consumer yes SYNC producer yes SYNC consumer yes TIME producer yes TIME consumer yes LSS producer no LSS consumer no"},{"location":"#basic-example","title":"Basic Example","text":"<p>This is a short example that connects to socketcan, reads remote node device name \\ and performs a network scan.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/samsamfire/gocanopen/pkg/network\"\n    \"github.com/samsamfire/gocanopen/pkg/od\"\n)\n\nfunc main() {\n\n    network := network.NewNetwork(nil)\n    err := network.Connect(\"socketcan\", \"can0\", 500_000)\n    if err != nil {\n        panic(err)\n    }\n    defer network.Disconnect()\n\n    // Add a remote node to the network, either by providing an EDS file\n    // Or downloading from the node. We use here a default OD available with the library\n    node, err := network.AddRemoteNode(0x10, od.Default())\n    if err != nil {\n        panic(err)\n    }\n\n    // Read standard entry containing device name (0x1008)\n    value, err := node.Configurator().ReadManufacturerDeviceName()\n    if err != nil {\n        fmt.Printf(\"error reading node %v device name : %v\\n\", node.GetID(), err)\n    } else {\n        fmt.Printf(\"node %v device name is %v\\n\", node.GetID(), value)\n    }\n\n    // Perform a network scan to detect other nodes...\n    res, err := network.Scan(1000)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(\"scanned the following nodes : \", res)\n}\n</code></pre>"},{"location":"can/","title":"CAN driver","text":"<p>In order to be able to connect to the CAN network, a specific driver is needed. Currently, this library comes with 3 supported devices :</p> <ul> <li>socketcan (including vcan)</li> <li>kvaser</li> <li>virtualcan here</li> </ul> <p>Note : In order to use kvaser, kvaser canlib should be downloaded &amp; installed. Specific compile flags are required : - CFLAGS: -g -Wall -I/path_to_kvaser/canlib/include - LDFLAGS: -L/path_to_kvaser/canlib</p>"},{"location":"can/#socketcan","title":"SocketCAN","text":"<p>Multiple versions of the socketcan driver exists, in particular :</p> <ul> <li>socketcan (standard socket recv/write)</li> <li>socketcanv3 (standard socket write, reads are done using recvmmsg)</li> <li>socketcanring (standard socket write, reads are done using an rx buffer ring)</li> </ul> <p>In particular the socketcanring implementation can drastically boost RX performance on smaller embedded systems if latency is not an issue.</p>"},{"location":"can/#creating-a-custom-driver","title":"Creating a custom driver","text":"<p>More transceivers can be added by creating your own driver and implementing the following interface :</p> <p><pre><code>type Bus interface {\n    Connect(...any) error                   // Connect to the actual bus\n    Disconnect() error                      // Disconnect from bus\n    Send(frame Frame) error                 // Send a frame on the bus\n    Subscribe(callback FrameListener) error // Subscribe to all can frames\n}\n</code></pre> Feel free to contribute to add specific drivers, we will find a way to integrate them in this repo.</p>"},{"location":"configurator/","title":"Configurator","text":"<p>This library comes with a NodeConfigurator that can be used to easily  get / update CANopen behaviour using CiA defined entries.</p> <p>The following is a non-exhaustive example :</p> <pre><code>config := net.Configurator(0x20) // create a NodeConfigurator object for node 0x20\n\n// Configure RPDO 1\nvar pdoNb uint8 = 0\n\n// Read / write event timer\nconf.WriteEventTimer(pdoNb, 1111)\neventTimer, _ := conf.ReadEventTimer(pdoNb)\nfmt.Prinln(\"event timer\",eventTimer)\n\n// Read / write transmission type\nconf.WriteTransmissionType(pdoNb,11)\ntransType, _ := conf.ReadTransmissionType(pdoNb)\nfmt.Prinln(\"transmission type\",transType)\n\n// Clear current mapping\nconf.ClearMappings(pdoNb)\n\n// Write / read PDO mapping\nvar Mapping = []config.PDOMappingParameter{\n    {Index: 0x2001, Subindex: 0x0, LengthBits: 8},\n    {Index: 0x2002, Subindex: 0x0, LengthBits: 8},\n    {Index: 0x2003, Subindex: 0x0, LengthBits: 16},\n    {Index: 0x2004, Subindex: 0x0, LengthBits: 32},\n}\n_ = conf.WriteMappings(pdoNb, Mapping)\n\nmapping, _ := conf.ReadMappings(pdoNb)\nfmt.Println(\"mapping\",mapping)\n\n// Update COB-ID\nconf.WriteCanIdPDO(pdoNb, 0x211)\n\n// Read hole configuration\nconfig, _ := conf.ReadConfigurationPDO(pdoNb)\nfmt.Println(\"pdo config\",config)\n</code></pre> <p>Other configuration APIs exist for SDO, HB, SYNC, TIME, NMT, ...</p>"},{"location":"local/","title":"Creating a LocalNode (slave node)","text":"<p>A LocalNode is the CiA 301 implementation of a CANopen node in golang. It has its own CANopen stack, which is run within a goroutine. When creating a local node, the library parses the EDS file and creates the relevant CANopen objects (including the Object Dictionary). This differs from other implementations that usually require a pre-build step that generates .c/.h files.</p>"},{"location":"local/#usage","title":"Usage","text":"<p>To create and start a CANopen node:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"github.com/samsamfire/gocanopen/pkg/network\"\n    \"github.com/samsamfire/gocanopen/pkg/od\"\n)\n\nfunc main() {\n    // 1. Initialize Network\n\nnet := network.NewNetwork(nil)\n    if err := net.Connect(\"socketcan\", \"can0\", 500000); err != nil {\n        log.Fatal(err)\n    }\n    defer net.Disconnect()\n\n    // 2. Create a LocalNode (Slave) with ID 0x10\n    // Using default embedded EDS\n    node, err := net.CreateLocalNode(0x10, od.Default())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Alternatively, load from an EDS file:\n    // node2, err := net.CreateLocalNode(0x11, \"path/to/slave.eds\")\n\n    // The node automatically enters NMT state OPERATIONAL\n    select {} // Keep running\n}\n</code></pre>"},{"location":"local/#local-od-access-sdo-interface","title":"Local OD Access (SDO Interface)","text":"<p>The <code>LocalNode</code> provides a direct API to interact with its internal Object Dictionary (OD). This is equivalent to performing SDO operations locally. You can Read and Write entries using their Index/SubIndex or their Name (as defined in the EDS).</p>"},{"location":"local/#reading-values","title":"Reading Values","text":"<p>The API provides typed helpers to read values. These helpers handle type casting where possible to simplify usage.</p> <p>Read String</p> <pre><code>// Read by Name\ndeviceName, err := node.ReadString(\"Manufacturer device name\", 0)\n\n// Read by Index/SubIndex (0x1008:00 is Device Name)\ndeviceName, err := node.ReadString(0x1008, 0x0)\n</code></pre> <p>Read Integers (Uint/Int) The <code>ReadUint</code> and <code>ReadInt</code> methods automatically cast the underlying OD value to <code>uint64</code> or <code>int64</code>.</p> <pre><code>// Read an UNSIGNED8 entry (0x1001 Error Register)\n// Returns uint64\nerrReg, err := node.ReadUint(0x1001, 0) \n\n// Read using Entry Name (assuming \"SomeParam\" exists)\n// Returns int64\nval, err := node.ReadInt(\"SomeParam\", 0) \n</code></pre> <p>Read Floats The <code>ReadFloat</code>, <code>ReadFloat32</code>, and <code>ReadFloat64</code> methods are available for REAL types.</p> <pre><code>// Read a REAL32 (float32) entry\n// Returns float64 (cast from float32)\nval, err := node.ReadFloat(0x2001, 0)\n\n// Read REAL32 specifically as float32\nf32Val, err := node.ReadFloat32(\"MyFloat32Param\", 0)\n\n// Read REAL64 specifically as float64\nf64Val, err := node.ReadFloat64(\"MyFloat64Param\", 0)\n</code></pre>"},{"location":"local/#writing-values","title":"Writing Values","text":"<p>To write values to the OD, you can use <code>WriteAnyExact</code>. This method writes the provided value to the specified entry. The value's type must match the OD entry's expected type (or be compatible).</p> <pre><code>// Write a uint32 value to Index 0x2000, SubIndex 0\nerr := node.WriteAnyExact(0x2000, 0, uint32(12345))\n\n// Write a string\nerr := node.WriteAnyExact(0x1008, 0, \"My Custom Device\")\n\n// Write using Name\nerr := node.WriteAnyExact(\"Producer heartbeat time\", 0, uint16(1000))\n\n// Write a float32\nerr := node.WriteAnyExact(0x2001, 0, float32(12.34))\n\n// Write a float64\nerr := node.WriteAnyExact(0x2002, 0, float64(56.78))\n</code></pre> <p>Note: It is recommended to cast your Go values to the specific type expected by the OD entry (e.g. <code>uint16</code>, <code>int8</code>, <code>uint32</code>) to ensure successful type checking.</p>"},{"location":"local/#writing-raw-bytes","title":"Writing Raw Bytes","text":"<p>You can write raw bytes directly to an OD entry using <code>WriteBytes</code>. This is useful for <code>DOMAIN</code> types or when you want to bypass type checking and write the raw binary representation directly.</p> <pre><code>// Write raw bytes to a DOMAIN entry or similar\ndata := []byte{0x01, 0x02, 0x03, 0x04}\nerr := node.WriteBytes(0x3000, 0, data)\n</code></pre>"},{"location":"local/#error-handling","title":"Error Handling","text":"<p>The API returns specific errors from the <code>od</code> package when operations fail. Handling these allows for robust application logic.</p> <p>Common Errors:</p> <ul> <li><code>od.ErrIdxNotExist</code>: The requested Index does not exist in the OD.</li> <li><code>od.ErrSubNotExist</code>: The Index exists, but the SubIndex does not.</li> <li><code>od.ErrTypeMismatch</code>: The requested read type or provided write value does not match the OD entry's type.</li> <li><code>od.ErrObjectNotWritable</code>: Trying to write to a read-only entry.</li> </ul> <p>Example: Robust Read/Write with Error Checking</p> <pre><code>func updateParameter(node *network.LocalNode) {\n    // Try to read a value\n    val, err := node.ReadUint(0x2000, 0)\n    if err != nil {\n        switch err {\n        case od.ErrIdxNotExist:\n            log.Printf(\"Parameter 0x2000 not found in EDS\")\n        case od.ErrTypeMismatch:\n            log.Printf(\"Parameter 0x2000 is not a Uint\")\n        default:\n            log.Printf(\"Read failed: %v\", err)\n        }\n        return\n    }\n\n    fmt.Printf(\"Current Value: %d\\n\", val)\n\n    // Try to write a new value\n    newValue := uint32(val + 1)\n    err = node.WriteAnyExact(0x2000, 0, newValue)\n    if err != nil {\n        log.Printf(\"Failed to write: %v\", err)\n    } else {\n        log.Println(\"Value updated successfully\")\n    }\n}\n</code></pre>"},{"location":"local/#special-od-entries-node-behavior","title":"Special OD Entries &amp; Node Behavior","text":"<p>Certain Object Dictionary entries are linked to the internal behavior of the <code>LocalNode</code>. When these entries are written to (either locally or via a remote SDO client), the node automatically updates its configuration or behavior.</p> <p>The supported special objects are listed in the Special entries table in od.md. These typically include entries in the Communication Profile Area (0x1000 - 0x1FFF), such as:</p> <ul> <li> <p>0x1017: Producer Heartbeat Time: Updating this value changes how often the node sends its heartbeat message.</p> </li> <li> <p>0x1016: Consumer Heartbeat Time: Updating this allows the node to start or stop monitoring heartbeats from other nodes.</p> </li> <li> <p>Dynamic PDO Reconfiguration: The <code>LocalNode</code> supports dynamic PDO mapping and communication parameter updates (0x1400-0x15FF/0x1800-0x19FF for communication and 0x1600-0x17FF/0x1A00-0x1BFF for mapping).</p> </li> </ul>"},{"location":"local/#example-master-updating-slave-heartbeat","title":"Example: Master Updating Slave Heartbeat","text":"<p>A common use case is a Master node reconfiguring a Slave node's heartbeat frequency over the network.</p> <p>Slave Side (LocalNode): The slave node simply needs to be running. It has 0x1017 defined in its EDS.</p> <p>Master Side: The master can use a <code>NodeConfigurator</code> to update the slave's heartbeat time.</p> <pre><code>// Create a configurator for the slave node (ID 0x10) (this is basically a wrapper around an SDO client)\nconfig := net.Configurator(0x10)\n\n// Update slave's heartbeat producer time to 500ms\n// This will perform an SDO write to index 0x1017:00 on the slave\nerr := config.WriteProducerHeartbeatTime(500)\n</code></pre> <p>What happens internally: 1. The Master sends an SDO Download request to the Slave for entry <code>0x1017:00</code>. 2. The Slave's <code>LocalNode</code> receives the SDO request. 3. Because <code>0x1017</code> has a special Extension registered, the new value is not just stored in the OD; it also triggers a configuration update in the Slave's NMT service. 4. The Slave immediately starts sending heartbeats every 500ms.</p>"},{"location":"local/#sdo-server-behavior","title":"SDO Server Behavior","text":"<p>The <code>LocalNode</code> automatically acts as an SDO Server. It handles SDO requests from other nodes (SDO Clients) on the network implicitly.</p> <ul> <li>Reads (SDO Upload): Remote nodes can read values from this node's OD.</li> <li>Writes (SDO Download): Remote nodes can write values to this node's OD.</li> </ul> <p>The values read/written via remote SDO are the same ones accessed via the <code>Read...</code> and <code>Write...</code> local API documented above. The <code>LocalNode</code> ensures atomicity and consistency.</p>"},{"location":"network/","title":"Network","text":"<p>The Network object is used for managing the CAN network &amp; stack. It holds CANopen Nodes which can be of two types : Either a LocalNode, which represents a real CANopen CiA 301 compliant node or a RemoteNode which is the  local representation of a remote CANopen node on the CAN bus used for master control.</p> <p>The network already embeds some CANopen functionalities such as : - SDO Client - NMT Master</p> <p>SDO client can be used by running :</p> <pre><code>// Read node id 0x10, index 0x2000, subindex 0x0 inside buffer\n// No decoding is done\nnbRead,err := network.ReadRaw(0x10,0x2000,0,buffer)\n\n// Write node id 0x10, index 0x2000, subindex 0x0\n// value can be any CANopen standard type\nvalue := uint16(600)\nnbRead,err := network.WriteRaw(0x10,0x2000,0,value,false)\n</code></pre> <p>NMT Master :</p> <pre><code>// RESET all nodes on the network\nnetwork.Command(0,nmt.CommandResetNode)\n\n// RESET node id 0x10\nnetwork.Command(0x10,nmt.CommandResetNode)\n</code></pre> <p>A network scan of all the available devices can be performed. This will send  an SDO request to all the nodes and wait for a reply. This expects the identity object to exist on the remote node (in conformance with CiA standard).</p> <pre><code>// Scan for existing nodes on the bus, if no response is received after 1 second\n// It is considered as non existent\ntimeoutMs := 1000\ndevices,err := network.Scan(1000)\n</code></pre>"},{"location":"network/#remote-node","title":"Remote node","text":"<p>A remote node can be used to control another node on the CAN bus. To create a remote node, several options are possible : - By providing an object dictionary (either EDS file, or ObjectDictionary object) - By downloading the EDS from the remote node (SDO upload). In that case, two formats are currently supported by default : ASCII and ZIP.</p> <pre><code>// Add a remote node, with id 6 and load the object dictionary from given file\nnode := network.AddRemoteNode(6, \"/path/to/object_dictionary.eds\")\n\n// First download EDS file. An optional callback can be provided for manufacturer specific parsing\n// Then add remote node\nodict,_ := network.ReadEDS(6, nil)\nnode := network.AddRemoteNode(6, odict)\n</code></pre>"},{"location":"network/#local-node","title":"Local node","text":"<p>A local node is a fully functional CANopen node as specified by CiA 301 standard. A node can be created with the following commands:</p> <pre><code>// Create &amp; start a local node with the default OD in the libraray\nnode,err := network.CreateLocalNode(0x10,od.Default())\n</code></pre>"},{"location":"network/#custom-od-parsing","title":"Custom OD parsing","text":"<p>The network can be configured to use a different OD parser when creating local nodes.</p> <pre><code>// Change default OD parser\nnetwork.SetParsev2(od.ParserV2)\n</code></pre>"},{"location":"network/#custom-node-processing","title":"Custom node processing","text":"<p>Nodes can also be added to network and controlled locally with a NodeProcessor. e.g.</p> <pre><code>// Create a local node\nnode, err := network.NewLocalNode(\n        network.BusManager,\n        slog.Default(),\n        odNode, // OD object ==&gt; Should be created\n        nil, // Use definition from OD\n        nil, // Use definition from OD\n        nodeId,\n        nmt.StartupToOperational,\n        500,\n        sdo.DefaultClientTimeout,\n        sdo.DefaultServerTimeout,\n        true,\n        nil,\n    )\n\n\n// Add a custom node to network and control it independently\nproc,err := network.AddNode(node)\n\n// Start node processing\nerr = proc.Start(context.Background())\n</code></pre> <p>More information on local nodes here</p>"},{"location":"od/","title":"ObjectDictionary","text":"<p>Every CANopen node has an ObjectDictionary. An ObjectDictionary consists of Entries with a given index between 0 and 0xFFFF. An entry may also have a subindex for some specific CANopen types like RECORD or ARRAY types. This subindex must be between 0 and 0xFF. All of this information is stored inside of an EDS file as defined by CiA. This library can parse a standard EDS file and create the corresponding CANopen objects (SDO, NMT, etc...). </p>"},{"location":"od/#supported-datatypes","title":"Supported Datatypes","text":"<p>The library supports the standard CANopen datatypes defined in CiA 301.</p> Name Code Description BOOLEAN 0x01 Boolean (true/false) INTEGER8 0x02 8-bit signed integer INTEGER16 0x03 16-bit signed integer INTEGER32 0x04 32-bit signed integer UNSIGNED8 0x05 8-bit unsigned integer UNSIGNED16 0x06 16-bit unsigned integer UNSIGNED32 0x07 32-bit unsigned integer REAL32 0x08 32-bit floating point VISIBLE_STRING 0x09 ASCII string OCTET_STRING 0x0A Byte array UNICODE_STRING 0x0B Unicode string DOMAIN 0x0F Large variable data (e.g., file transfer) REAL64 0x11 64-bit floating point INTEGER64 0x15 64-bit signed integer UNSIGNED64 0x1B 64-bit unsigned integer"},{"location":"od/#basic-usage","title":"Basic Usage","text":"<p>To create an ObjectDictionary directly :</p> <pre><code>import \"github.com/samsamfire/gocanopen/pkg/od\"\n\nodict := od.Parse(\"../testdata/base.eds\", 0x20) // parse EDS for node id 0x20\n</code></pre> <p>The node id is required but is only useful when the EDS uses the special variable $NODE_ID. Usually, the ObjectDictionary is created when adding / creating a node on the network. Accessing OD entries and subentries directly is possible either by name or by value.</p> <pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\nodict.Index(0x201B) // get entry index by value\nodict.Index(\"UNSIGNED64 value\") // accessing with the actual name is also possible\nodict.Index(0x201B).SubIndex(0) // returns the associated Variable object (for VAR types, subindex is always 0)\nodict.Index(0x1018).SubIndex(1) // access sub-object of array\n</code></pre> <p>You can also iterate over all entries:</p> <pre><code>entries := odict.Entries()\nfor idx, entry := range entries {\n    fmt.Printf(\"Index: %X, Name: %s\\n\", idx, entry.Name)\n}\n</code></pre> <p>It is also possible to create new dictionary entries dynamically :</p> <pre><code>odict.AddVariableType(index, indexName, od.DOMAIN, od.AttributeSdoRw, \"\") // add a DOMAIN entry, and returns it\nodict.AddVariableType(0x2500, \"a number\", od.UNSIGNED32, od.AttributeSdoRw, \"0x1000\") // add an UNSIGNED32 entry, readable and writable\nrecord := od.NewRecord()\nrecord.AddSubObject(0, \"sub0\", od.UNSIGNED8, od.AttributeSdoRw, \"0x11\")\nodict.AddVariableList(0x3030, \"record\", record) // add a RECORD entry\n</code></pre> <p>Some more complex objects can be created dynamically, currently only a few are supported :</p> <p><pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\nodict.AddRPDO(1) // adds an rpdo object to EDS. i.e. new communication param at 0x1400 and mapping param at 0x1600\nodict.AddTPDO(1) // adds a tpdo object to EDS. i.e. new communication param at 0x1800 and mapping param at 0x1A00\nodict.AddSYNC() // adds sync object as well as extensions (1005,1006,1007,1019)\n</code></pre> Note that currently adding these objects will not update the underlying EDS file on the system, meaning that downloading EDS through object 0x1021 for example will still return the original EDS file.</p> <p>A default CANopen EDS is embedded inside of this package. It can be useful for testing purposes, and can be used like so :</p> <pre><code>odict := od.Default() // this creates a default object dictionary with pre-configured values\n</code></pre>"},{"location":"od/#exporting","title":"Exporting","text":"<p>Exporting OD to an EDS file is also possible. OD can be exported with default or current values.</p> <pre><code>    od.ExportEDS(odict,true,\"path_to_exported.eds\")\n</code></pre>"},{"location":"od/#special-entries","title":"Special entries","text":"<p>CiA 301 defines a certain number of CANopen communication specific objects inside the object dictionary.  These objects are inside of the Communication Profile Area and range between 0x1000 - 0x1FFF.  Some of them are mandatory and others are optional. The following table lists the available objects, and the ones that are currently implemented in this stack.</p> Index Name Implemented 1000 device type yes 1001 error register yes 1003 manufacturer status register yes 1005 COB-ID SYNC yes 1006 communication cycle period yes 1007 synchronous window length yes 1008 manufacturer device name yes 1009 manufacturer hardware version yes 100A manufacturer software version yes 100C gard time no 100D life time factor no 1010 store parameters no 1011 restore default parameters no 1012 COB-ID TIME yes 1013 high resolution time stamp yes 1014 COB-ID EMCY yes 1015 Inhibit Time EMCY yes 1016 Consumer heartbeat time yes 1017 Producer heartbeat time yes 1018 Identity Object yes 1021 Store EDS yes 1022 Storage Format yes 1400-15FF RPDO Communication Parameter yes 1600-17FF RPDO Mapping Parameter yes 1800-19FF TPDO Communication Parameter yes 1A00-1BFF TPDO Mapping Parameter yes <p>Check configuration on how to access these entries.</p> <p>These entries are different than regular OD entries as they use special extensions that can perform various operations on the running CANopen node. You can define your own CANopen extensions for this, you need to create two functions :</p> <ul> <li>An od.StreamReader that will be called on entry read access</li> <li>An od.StreamWriter that will be called on entry write access</li> </ul> <p>The default implementations, i.e. for regular reading and writing are od.ReadEntryDefault and od.WriteEntryDefault.</p> <pre><code>odict := od.Parse(od.Default(), 0x20)\nentry := odict.AddVariableType(index, indexName, od.DOMAIN, od.AttributeSdoRw, \"\")\nentry.AddExtension(someObject,od.ReadEntryDefault,od.WriteEntryDefault)\n</code></pre> <p>Some pre-made extensions are available :</p> <pre><code>odict := od.Parse(od.Default(), 0x20)\n// this will create a file on disk that will be accessible by SDO block transfer\nentry := odict.AddFile(0x3333, \"File entry\", \"./path_to_file.txt\", os.O_RDWR|os.O_CREATE, os.O_RDWR|os.O_CREATE)\n\n// Add an io.Reader as a DOMAIN entry (read-only)\nodict.AddReader(0x3334, \"Reader entry\", myReader)\n</code></pre>"},{"location":"sdo/","title":"SDO (Service Data Object)","text":"<p>The SDO protocol is used for direct access to a device's Object Dictionary (OD). It supports reading (Upload) and writing (Download) of values. All CiA 301 SDO transfer modes are supported:</p> <ul> <li>Expedited transfers</li> <li>Segmented transfers</li> <li>Block transfers</li> </ul>"},{"location":"sdo/#sdo-client-accessing-remote-nodes","title":"SDO Client (Accessing Remote Nodes)","text":"<p>To communicate with another node on the network (acting as an SDO Client), you typically use a <code>RemoteNode</code> or the <code>Network</code> raw API.</p>"},{"location":"sdo/#using-remotenode","title":"Using RemoteNode","text":"<p>If you have a <code>RemoteNode</code> instance (e.g., from <code>network.AddRemoteNode</code>), you can use its helper methods to read entries.</p> <pre><code>// Create a remote node, with id 6 and load the object dictionary from given file\nnode := network.AddRemoteNode(6, \"/path/to/object_dictionary.eds\")\n\n// Read a value (Index 0x2001, SubIndex 0)\ndata, err := node.Read(0x2001, 0)\nif err != nil {\n    // Handle SDO Abort or Timeout\n    log.Printf(\"SDO Read failed: %v\", err)\n}\n</code></pre>"},{"location":"sdo/#using-network-raw-api","title":"Using Network Raw API","text":"<p>You can also send SDO requests directly via the Network object without explicitly managing a RemoteNode.</p> <pre><code>// Read Raw: Node 0x10, Index 0x2000, SubIndex 0\nbuffer := make([]byte, 8)\nnbRead, err := network.ReadRaw(0x10, 0x2000, 0, buffer)\n\n// Write Raw: Node 0x10, Index 0x2000, SubIndex 0\nvalue := uint16(600)\n// false = disable block transfer (use expedited/segmented)\nnbWritten, err := network.WriteRaw(0x10, 0x2000, 0, value, false) \n</code></pre>"},{"location":"sdo/#sdo-server-local-node","title":"SDO Server (Local Node)","text":"<p>If you are running a <code>LocalNode</code>, it automatically acts as an SDO Server. To interact with the Local Node's OD (which is what SDO clients access), see the Local Node Documentation.</p>"}]}