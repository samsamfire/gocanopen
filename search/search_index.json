{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This package is aimed to be a modern, efficient and compliant CANopen stack written entirely in go. It features both slave &amp; master control and supports dynamic OD creation directly via EDS file.</p> <p>This project has been inspired by two other existing projects:</p> <ul> <li>CANopenNode a C implementation slave side.</li> <li>canopen a python implementation mostly for master control.</li> </ul> <p>This project implements both slave &amp; master side using an efficient API. Currently the following is implemented :</p> Service name Implemented SDO server yes SDO client yes NMT master yes NMT slave yes HB producer yes HB consumer yes TPDO yes RPDO yes EMERGENCY  producer yes EMERGENCY  consumer yes SYNC producer yes SYNC consumer yes TIME producer yes TIME consumer yes LSS producer no LSS consumer no"},{"location":"#basic-example","title":"Basic Example","text":"<p>This is a short example that connects to socketcan, reads remote node device name \\ and performs a network scan.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/samsamfire/gocanopen/pkg/network\"\n    \"github.com/samsamfire/gocanopen/pkg/od\"\n)\n\nfunc main() {\n\n    network := network.NewNetwork(nil)\n    err := network.Connect(\"socketcan\", \"can0\", 500_000)\n    if err != nil {\n        panic(err)\n    }\n    defer network.Disconnect()\n\n    // Add a remote node to the network, either by providing an EDS file\n    // Or downloading from the node. We use here a default OD available with the library\n    node, err := network.AddRemoteNode(0x10, od.Default())\n    if err != nil {\n        panic(err)\n    }\n\n    // Read standard entry containing device name (0x1008)\n    value, err := node.Configurator().ReadManufacturerDeviceName()\n    if err != nil {\n        fmt.Printf(\"error reading node %v device name : %v\\n\", node.GetID(), err)\n    } else {\n        fmt.Printf(\"node %v device name is %v\\n\", node.GetID(), value)\n    }\n\n    // Perform a network scan to detect other nodes...\n    res, err := network.Scan(1000)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(\"scanned the following nodes : \", res)\n}\n</code></pre>"},{"location":"can/","title":"CAN driver","text":"<p>In order to be able to connect to the CAN network, a specific driver is needed. Currently, this library comes with 3 supported devices :</p> <ul> <li>socketcan (including vcan)</li> <li>kvaser</li> <li>virtualcan here</li> </ul> <p>Note : In order to use kvaser, kvaser canlib should be downloaded &amp; installed. Specific compile flags are required : - CFLAGS: -g -Wall -I/path_to_kvaser/canlib/include - LDFLAGS: -L/path_to_kvaser/canlib</p>"},{"location":"can/#creating-a-custom-driver","title":"Creating a custom driver","text":"<p>More transceivers can be added by creating your own driver and implementing the following interface :</p> <p><pre><code>type Bus interface {\n    Connect(...any) error                   // Connect to the actual bus\n    Disconnect() error                      // Disconnect from bus\n    Send(frame Frame) error                 // Send a frame on the bus\n    Subscribe(callback FrameListener) error // Subscribe to all can frames\n}\n</code></pre> Feel free to contribute to add specific drivers, we will find a way to integrate them in this repo.</p>"},{"location":"configurator/","title":"Configurator","text":"<p>This library comes with a NodeConfigurator that can be used to easily  get / update CANopen behaviour using CiA defined entries.</p> <p>The following is a non-exhaustive example :</p> <pre><code>config := net.Configurator(0x20) // create a NodeConfigurator object for node 0x20\n\n// Configure RPDO 1\nvar pdoNb uint8 = 0\n\n// Read / write event timer\nconf.WriteEventTimer(pdoNb, 1111)\neventTimer, _ := conf.ReadEventTimer(pdoNb)\nfmt.Prinln(\"event timer\",eventTimer)\n\n// Read / write transmission type\nconf.WriteTransmissionType(pdoNb,11)\ntransType, _ := conf.ReadTransmissionType(pdoNb)\nfmt.Prinln(\"transmission type\",transType)\n\n// Clear current mapping\nconf.ClearMappings(pdoNb)\n\n// Write / read PDO mapping\nvar Mapping = []config.PDOMappingParameter{\n    {Index: 0x2001, Subindex: 0x0, LengthBits: 8},\n    {Index: 0x2002, Subindex: 0x0, LengthBits: 8},\n    {Index: 0x2003, Subindex: 0x0, LengthBits: 16},\n    {Index: 0x2004, Subindex: 0x0, LengthBits: 32},\n}\n_ = conf.WriteMappings(pdoNb, Mapping)\n\nmapping, _ := conf.ReadMappings(pdoNb)\nfmt.Println(\"mapping\",mapping)\n\n// Update COB-ID\nconf.WriteCanIdPDO(pdoNb, 0x211)\n\n// Read hole configuration\nconfig, _ := conf.ReadConfigurationPDO(pdoNb)\nfmt.Println(\"pdo config\",config)\n</code></pre> <p>Other configuration APIs exist for SDO, HB, SYNC, TIME, NMT, ...</p>"},{"location":"local/","title":"Creating a LocalNode","text":"<p>A LocalNode is the CiA 301 implementation of a CANopen node in golang. It has it's own CANopen stack, which is run within a goroutine. When creating a local node, the library parses the EDS file and creates the relevant CANopen objects. This is different from other implementations that usually require a pre-build step  that generates .c/.h file that will then be used inside of the application.</p>"},{"location":"local/#usage","title":"Usage","text":"<p>To create a CANopen node :</p> <p><pre><code>network := canopen.NewNetwork(nil)\nnetwork.Connect(\"socketcan\",\"can0\",500000)\ndefer network.Disconnect() // properly disconnect\n\n// Create a node with id 0x10 using the example EDS\nnode := canopen.CreateLocalNode(0x10,\"../testdata/base.eds\")\n</code></pre> Thats it ! The node will go automatically to NMT state OPERATIONAL if there are no errors. A callback can be added that will be called by the node's goroutine. It must be non blocking.</p> <pre><code>// Called every stack tick, i.e. ~10ms\nfunc NodeMainCallback(node canopen.Node) {\n    od := node.GetOD()\n    // Get manufacturer device name\n    deviceName, _ := od.Index(0x1008).GetRawData(0, 0)\n    fmt.Println(\"My name is : \", string(deviceName))\n}\n\nnode.SetMainCallback(NodeMainCallback)\n</code></pre> <p>Note that there are several ways of accessing data in the object dictionnary. Some standard functions are provided for direct memory access to the OD. However, all nodes come with a local sdo client for  reading the internal OD. Here are some examples:</p> <pre><code>od := node.GetOD()\nod.Index(\"UNSIGNED32 value\").Uint32(0) // Get od value as a uint32, if length is incorrect, it will error\n\nlocalNode := node.(*canopen.LocalNode) // Get actual type : *canopen.LocalNode\nlocalNode.ReadUint(\"UNSIGNED32\",\"\") // Returns it as uint64\nlocalNode.ReadUint(\"UNSIGNED8\",\"\") // Returns it as uint64 also\ndeviceName,_ := localNode.ReadString(0x1008, 0x0) // This corresponds to device name\n</code></pre> <p>See BaseNode go doc for more information on the available methods.</p>"},{"location":"network/","title":"Network","text":"<p>The Network object is used for managing the CAN network &amp; stack. It holds CANopen Nodes which can be of two types : Either a LocalNode, which represents a real CANopen CiA 301 compliant node or a RemoteNode which is the  local representation of a remote CANopen node on the CAN bus used for master control.</p> <p>The network already embeds some CANopen functionalities such as : - SDO Client - NMT Master</p> <p>SDO client can be used by running :</p> <pre><code>// Read node id 0x10, index 0x2000, subindex 0x0 inside buffer\n// No decoding is done\nnbRead,err := network.ReadRaw(0x10,0x2000,0,buffer)\n\n// Write node id 0x10, index 0x2000, subindex 0x0\n// value can be any CANopen standard type\nvalue := uint16(600)\nnbRead,err := network.WriteRaw(0x10,0x2000,0,value,false)\n</code></pre> <p>NMT Master :</p> <pre><code>// RESET all nodes on the network\nnetwork.Command(0,nmt.CommandResetNode)\n\n// RESET node id 0x10\nnetwork.Command(0x10,nmt.CommandResetNode)\n</code></pre> <p>A network scan of all the available devices can be performed. This will send  an SDO request to all the nodes and wait for a reply. This expects the identity object to exist on the remote node (in conformance with CiA standard).</p> <pre><code>// Scan for existing nodes on the bus, if no response is received after 1 second\n// It is considered as non existent\ntimeoutMs := 1000\ndevices,err := network.Scan(1000)\n</code></pre>"},{"location":"network/#remote-node","title":"Remote node","text":"<p>A remote node can be used to control another node on the CAN bus. To create a remote node, several options are possible : - By providing an object dictionary (either EDS file, or ObjectDictionary object) - By downloading the EDS from the remote node (SDO upload). In that case, two formats are currently supported by default : ASCII and ZIP.</p> <pre><code>// Add a remote node, with id 6 and load the object dictionary from given file\nnode := network.AddRemoteNode(6, \"/path/to/object_dictionary.eds\")\n\n// First download EDS file. An optional callback can be provided for manufacturer specific parsing\n// Then add remote node\nodict,_ := network.ReadEDS(6, nil)\nnode := network.AddRemoteNode(6, odict)\n</code></pre>"},{"location":"network/#local-node","title":"Local node","text":"<p>A local node is a fully functional CANopen node as specified by CiA 301 standard. A node can be created with the following commands:</p> <pre><code>// Create &amp; start a local node with the default OD in the libraray\nnode,err := network.CreateLocalNode(0x10,od.Default())\n</code></pre>"},{"location":"network/#custom-od-parsing","title":"Custom OD parsing","text":"<p>The network can be configured to use a different OD parser when creating local nodes.</p> <pre><code>// Change default OD parser\nnetwork.SetParsev2(od.ParserV2)\n</code></pre>"},{"location":"network/#custom-node-processing","title":"Custom node processing","text":"<p>Nodes can also be added to network and controlled locally with a NodeProcessor. e.g.</p> <pre><code>// Create a local node\nnode, err := network.NewLocalNode(\n        network.BusManager,\n        slog.Default(),\n        odNode, // OD object ==&gt; Should be created\n        nil, // Use definition from OD\n        nil, // Use definition from OD\n        nodeId,\n        nmt.StartupToOperational,\n        500,\n        sdo.DefaultClientTimeout,\n        sdo.DefaultServerTimeout,\n        true,\n        nil,\n    )\n\n\n// Add a custom node to network and control it independently\nproc,err := network.AddNode(node)\n\n// Start node processing\nerr = proc.Start(context.Background())\n</code></pre> <p>More information on local nodes here</p>"},{"location":"od/","title":"ObjectDictionary","text":"<p>Every CANopen node has an ObjectDictionary. An ObjectDictionary consists of Entries with a given index between 0 and 0xFFFF. An entry may also have a subindex for some specific CANopen types like RECORD or ARRAY types. This subindex must be between 0 and 0xFF. All of this information is stored inside of an EDS file as defined by CiA. This library can parse a standard EDS file and create the corresponding CANopen objects (SDO, NMT, etc...).</p>"},{"location":"od/#basic-usage","title":"Basic Usage","text":"<p>To create an ObjectDictionary directly :</p> <p><pre><code>import \"github.com/samsamfire/gocanopen/pkg/od\"\n\nodict := od.Parse(\"../testdata/base.eds\", 0x20) // parse EDS for node id 0x20\n</code></pre> The node id is required but is only useful when the EDS uses the special variable $NODE_ID. Usually, the ObjectDictionary is created when adding / creating a node on the network. Accessing OD entries and subentries directly is possible either by name or by value.</p> <pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\nodict.Index(0x201B) // get entry index by value\nodict.Index(\"UNSIGNED64 value\") // accessing with the actual name is also possible\nodict.Index(0x201B).SubIndex(0) // returns the associated Variable object (for VAR types, subindex is always 0)\nodict.Index(0x1018).SubIndex(1) // access sub-object of array\n</code></pre> <p>It is also possible to create new dictionary entries dynamically :</p> <pre><code>odict.AddVariableType(index, indexName, od.DOMAIN, od.AttributeSdoRw, \"\") // add a DOMAIN entry, and returns it\nodict.AddVariableType(0x2500, \"a number\", od.UNSIGNED32, od.AttributeSdoRw, \"0x1000\") // add an UNSIGNED32 entry, readable and writable\nrecord := od.NewRecord()\nrecord.AddSubObject(0, \"sub0\", od.UNSIGNED8, od.AttributeSdoRw, \"0x11\")\nodict.AddVariableList(0x3030, \"record\", record) // add a RECORD entry\n</code></pre> <p>Some more complex objects can be created dynamically, currently only a few are supported :</p> <p><pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\nodict.AddRPDO(1) // adds an rpdo object to EDS. i.e. new communication param at 0x1400 and mapping param at 0x1600\nodict.AddTPDO(1) // adds a tpdo object to EDS. i.e. new communication param at 0x1800 and mapping param at 0x1A00\nodict.AddSYNC() // adds sync object as well as extensions (1005,1006,1007,1019)\n</code></pre> Note that currently adding these objects will not update the underlying EDS file on the system, meaning that downloading EDS through object 0x1021 for example will still return the original EDS file.</p> <p>A default CANopen EDS is embedded inside of this package. It can be useful for testing purposes, and can be used like so :</p> <pre><code>odict := od.Default() // this creates a default object dictionary with pre-configured values\n</code></pre>"},{"location":"od/#exporting","title":"Exporting","text":"<p>Exporting OD to an EDS file is also possible. OD can be exported with default or current values.</p> <pre><code>    od.ExportEDS(odict,true,\"path_to_exported.eds\")\n</code></pre>"},{"location":"od/#special-entries","title":"Special entries","text":"<p>CiA 301 defines a certain number of CANopen communication specific objects inside the object dictionary.  These objects are inside of the Communication Profile Area and range between 0x1000 - 0x1FFF.  Some of them are mandatory and others are optional. The following table lists the available objects, and the ones that are currently implemented in this stack.</p> Index Name Implemented 1000 device type yes 1001 error register yes 1003 manufacturer status register yes 1005 COB-ID SYNC yes 1006 communication cycle period yes 1007 synchronous window length yes 1008 manufacturer device name yes 1009 manufacturer hardware version yes 100A manufacturer software version yes 100C gard time no 100D life time factor no 1010 store parameters no 1011 restore default parameters no 1012 COB-ID TIME yes 1013 high resolution time stamp yes 1014 COB-ID EMCY yes 1015 Inhibit Time EMCY yes 1016 Consumer heartbeat time yes 1017 Producer heartbeat time yes 1018 Identity Object yes 1021 Store EDS yes 1022 Storage Format yes <p>Check configuration on how to access these entries.</p> <p>These entries are different than regular OD entries as they use special extensions that can perform various operations on the running CANopen node. You can define your own CANopen extensions for this, you need to create two functions :</p> <ul> <li>An od.StreamReader that will be called on entry read access</li> <li>An od.StreamWriter that will be called on entry write access</li> </ul> <p>The default implementations, i.e. for regular reading and writing are od.ReadEntryDefault and od.WriteEntryDefault.</p> <pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\nentry := odict.AddVariableType(index, indexName, od.DOMAIN, od.AttributeSdoRw, \"\")\nentry.AddExtension(someObject,od.ReadEntryDefault,od.WriteEntryDefault)\n</code></pre> <p>Some pre-made extensions are available : <pre><code>odict := od.Parse(\"../testdata/base.eds\", 0x20)\n// this will create a file on disk that will be accessible by SDO block transfer\nentry := odict.AddFile(0x3333, \"File entry\", \"./path_to_file.txt\", os.O_RDWR|os.O_CREATE, os.O_RDWR|os.O_CREATE)\n</code></pre></p>"},{"location":"sdo/","title":"SDO","text":"<p>The SDO protocol can be used to read or write values to a CANopen node. All the SDO features of the CiA 301 are supported. This includes : - expedited transfers - segmented transfers - block transfers</p> <p>Object dictionary entries can be read or written to either by name or by index and sub-index.</p> <pre><code>// Create a remote node, with id 6 and load the object dictionary from given file\nnode := network.AddRemoteNode(6, \"/path/to/object_dictionary.eds\")\nnode.Read(0x2001,0)\n</code></pre>"}]}